<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rollup And Pre-Aggregates &#8212; OpenTSDB 2.4 documentation</title>
    <link rel="stylesheet" href="../_static/solar.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="UIDs and TSUIDs" href="uids.html" />
    <link rel="prev" title="Query Details and Stats" href="query/stats.html" /><link href='http://fonts.googleapis.com/css?family=Source+Code+Pro|Open+Sans:300italic,400italic,700italic,400,300,700' rel='stylesheet' type='text/css'>
<link href="../_static/solarized-dark.css" rel="stylesheet">
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-18339382-1']);
  _gaq.push(['_setDomainName', 'none']);
  _gaq.push(['_setAllowLinker', true]);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="uids.html" title="UIDs and TSUIDs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="query/stats.html" title="Query Details and Stats"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">OpenTSDB 2.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">User Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Rollup And Pre-Aggregates</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Rollup And Pre-Aggregates</a><ul>
<li><a class="reference internal" href="#example-data">Example Data</a></li>
<li><a class="reference internal" href="#rollups">Rollups</a><ul>
<li><a class="reference internal" href="#rollup-example">Rollup Example</a></li>
<li><a class="reference internal" href="#averaging-rollup-example">Averaging Rollup Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pre-aggregates">Pre-Aggregates</a><ul>
<li><a class="reference internal" href="#pre-aggregate-example">Pre-Aggregate Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rolled-up-pre-aggregates">Rolled-up Pre-Aggregates</a></li>
<li><a class="reference internal" href="#generating-rollups-and-pre-aggregates">Generating Rollups and Pre-Aggregates</a><ul>
<li><a class="reference internal" href="#problems">Problems</a></li>
<li><a class="reference internal" href="#solutions">Solutions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuration">Configuration</a><ul>
<li><a class="reference internal" href="#aggregationids">aggregationIds</a></li>
<li><a class="reference internal" href="#intervals">intervals</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="query/stats.html"
                        title="previous chapter">Query Details and Stats</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="uids.html"
                        title="next chapter">UIDs and TSUIDs</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="rollup-and-pre-aggregates">
<h1>Rollup And Pre-Aggregates</h1>
<p>While TSDB is designed to store original, full resolution data as long as there is space, queries for wide time ranges or over many tag combinations can be quite painful. Such queries can take a long time to complete or, in the worst case, kill TSDs with out-of-memory exceptions. As of OpenTSDB 2.4, a set of new APIs allow for storing and querying lower resolution data to answer such queries much quicker. This page will give you an overview of what rollups and pre-aggregates are, how they work in TSDB and how best to use them. Look in the API’s section for specific implementation details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>OpenTSDB does not itself calculate and store rollup or pre-aggregated data. There are multiple ways to compute the results but they all have benefits and drawbacks depending on the scale and accuracy requirements. See the <a class="reference internal" href="#generating"><span class="std std-ref">Generating Rollups and Pre-Aggregates</span></a> section discussing how to create this data.</p>
</div>
<div class="section" id="example-data">
<h2>Example Data</h2>
<p>To help describe the lower resolution data, lets look at some full resolution (also known as <em>raw</em> data) example data. The first table defines the time series with a short-cut identifier.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Series ID</p></th>
<th class="head"><p>Metric</p></th>
<th class="head"><p>Tag 1</p></th>
<th class="head"><p>Tag 2</p></th>
<th class="head"><p>Tag 3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ts1</p></td>
<td><p>system.if.bytes.out</p></td>
<td><p>host=web01</p></td>
<td><p>colo=lga</p></td>
<td><p>interface=eth0</p></td>
</tr>
<tr class="row-odd"><td><p>ts2</p></td>
<td><p>system.if.bytes.out</p></td>
<td><p>host=web02</p></td>
<td><p>colo=lga</p></td>
<td><p>interface=eth0</p></td>
</tr>
<tr class="row-even"><td><p>ts3</p></td>
<td><p>system.if.bytes.out</p></td>
<td><p>host=web03</p></td>
<td><p>colo=sjc</p></td>
<td><p>interface=eth0</p></td>
</tr>
<tr class="row-odd"><td><p>ts4</p></td>
<td><p>system.if.bytes.out</p></td>
<td><p>host=web04</p></td>
<td><p>colo=sjc</p></td>
<td><p>interface=eth0</p></td>
</tr>
</tbody>
</table>
<p>Notice that they all have the same <code class="docutils literal notranslate"><span class="pre">metric</span></code> and <code class="docutils literal notranslate"><span class="pre">interface</span></code> tag, but different <code class="docutils literal notranslate"><span class="pre">host</span></code> and <code class="docutils literal notranslate"><span class="pre">colo</span></code> tags.</p>
<p>Next for some data written at 15 minute intervals:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Series ID</p></th>
<th class="head"><p>12:00</p></th>
<th class="head"><p>12:15</p></th>
<th class="head"><p>12:30</p></th>
<th class="head"><p>12:45</p></th>
<th class="head"><p>13:00</p></th>
<th class="head"><p>13:15</p></th>
<th class="head"><p>13:30</p></th>
<th class="head"><p>13:45</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ts1</p></td>
<td><p>1</p></td>
<td><p>4</p></td>
<td><p>-3</p></td>
<td><p>8</p></td>
<td><p>2</p></td>
<td><p>-4</p></td>
<td><p>5</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>ts2</p></td>
<td><p>7</p></td>
<td><p>2</p></td>
<td><p>8</p></td>
<td><p>-9</p></td>
<td><p>4</p></td>
<td></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>ts3</p></td>
<td><p>9</p></td>
<td><p>3</p></td>
<td><p>-2</p></td>
<td><p>-1</p></td>
<td><p>6</p></td>
<td><p>3</p></td>
<td><p>8</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>ts4</p></td>
<td></td>
<td><p>2</p></td>
<td><p>5</p></td>
<td><p>2</p></td>
<td><p>8</p></td>
<td><p>5</p></td>
<td><p>-4</p></td>
<td><p>7</p></td>
</tr>
</tbody>
</table>
<p>Notice that some data points are missing. With those data sets, lets look at rollups first.</p>
</div>
<div class="section" id="rollups">
<h2>Rollups</h2>
<p>A “rollup” is defined, in OpenTSDB, as a <strong>single</strong> time series aggregated over time. It may also be called a “time-based aggregation”. Rollups help to solve the problem of looking at wide time spans. For example, if you write a data point every 60 seconds and query for one year of data, a time series would return more than 525k individual data points. Graphing that many points could be pretty messy. Instead you may want to look at lower resolution data, say 1 hour data where you only have around 8k values to plot. Then you can identify anomalies and drill down for finer resolution data.</p>
<p>If you have already used OpenTSDB to query data, you are likely familiar with <strong>downsamplers</strong> that aggregate each time series into a smaller, or lower resolution, value. A rollup is essentially the result of a downsampler stored in the system and called up at will. Each rollup (or downsampler) requires two pieces of information:</p>
<ul class="simple">
<li><p><strong>Interval</strong> - How much time is “rolled” up into the new value. For example, <code class="docutils literal notranslate"><span class="pre">1h</span></code> for one hour of data or <code class="docutils literal notranslate"><span class="pre">1d</span></code> for a day of data.</p></li>
<li><p><strong>Aggregation Function</strong> - What arithmetic was performed on the underlying values to arrive at the new value. E.g. <code class="docutils literal notranslate"><span class="pre">sum</span></code> to add all of the values or <code class="docutils literal notranslate"><span class="pre">max</span></code> to store the largest.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When storing rollups, it’s best to avoid functions such as <strong>average</strong>, <strong>median</strong> or <strong>deviation</strong>. When performing further downsampling or grouping aggregations, such values become meaningless. Instead it’s much better to always store the <strong>sum</strong> and <strong>count</strong> from which, at least, the <strong>average</strong> can be computed at query time. For more information, see the section below.</p>
</div>
<p>The timestamp of a rolled-up data point should snap to the top of the rollup interval. E.g. if the rollup interval is <code class="docutils literal notranslate"><span class="pre">1h</span></code> then it contains 1 hour of data and should snap to the top of the hour. (As all timestamps are written in Unix Epoch format, defined as the UTC timezone, this would be the start of an hour UTC time).</p>
<div class="section" id="rollup-example">
<h3>Rollup Example</h3>
<p>Given the series above, lets store the <code class="docutils literal notranslate"><span class="pre">sum</span></code> and <code class="docutils literal notranslate"><span class="pre">count</span></code> with an interval of <code class="docutils literal notranslate"><span class="pre">1h</span></code>.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Series ID</p></th>
<th class="head"><p>12:00</p></th>
<th class="head"><p>13:00</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ts1 SUM</p></td>
<td><p>10</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>ts1 COUNT</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>ts2 SUM</p></td>
<td><p>8</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>ts2 COUNT</p></td>
<td><p>4</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>ts3 SUM</p></td>
<td><p>9</p></td>
<td><p>19</p></td>
</tr>
<tr class="row-odd"><td><p>ts3 COUNT</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>ts4 SUM</p></td>
<td><p>9</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-odd"><td><p>ts4 COUNT</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
</tr>
</tbody>
</table>
<p>Notice that all timestamps align to the top of the hour regardless of when the first data point in the interval “bucket” appears. Also notice that if a data point is not present for an interval, the count is lower.</p>
<p>In general, you should aim to compute and store the <code class="docutils literal notranslate"><span class="pre">MAX</span></code>, <code class="docutils literal notranslate"><span class="pre">MIN</span></code>, <code class="docutils literal notranslate"><span class="pre">SUM</span></code> and <code class="docutils literal notranslate"><span class="pre">COUNT</span></code> for each time series when storing rollups.</p>
</div>
<div class="section" id="averaging-rollup-example">
<h3>Averaging Rollup Example</h3>
<p>When rollups are enabled and you request a downsampler with the <code class="docutils literal notranslate"><span class="pre">avg</span></code> function from OpenTSDB, the TSD will scan storage for <code class="docutils literal notranslate"><span class="pre">SUM</span></code> and <code class="docutils literal notranslate"><span class="pre">COUNT</span></code> values. Then while iterating over the data it will accurately compute the average.</p>
<p>The timestamps for count and sum values must match. However, if the expected count value for a sum is missing, the sum will be kicked out of the results. Take the following example set from above where we’re now missing a count data point in <code class="docutils literal notranslate"><span class="pre">ts2</span></code>.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Series ID</p></th>
<th class="head"><p>12:00</p></th>
<th class="head"><p>13:00</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ts1 SUM</p></td>
<td><p>10</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>ts1 COUNT</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>ts2 SUM</p></td>
<td><p>8</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>ts2 COUNT</p></td>
<td><p>4</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>The resulting <code class="docutils literal notranslate"><span class="pre">avg</span></code> for a <code class="docutils literal notranslate"><span class="pre">2h</span></code> downsampling query would look like this:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 67%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Series ID</p></th>
<th class="head"><p>12:00</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ts1 AVG</p></td>
<td><p>1.875</p></td>
</tr>
<tr class="row-odd"><td><p>ts2 AVG</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="pre-aggregates">
<h2>Pre-Aggregates</h2>
<p>While rollups help with wide time span queries, you can still run into query performance issues with small ranges if the metric has high cardinality (i.e. the unique number of time series for the given metric). In the example above, we have 4 web servers. But lets say that we have 10,000 servers. Fetching the sum or average of interface traffic may be fairly slow. If users are often fetching the group by (or some think of it as the spatial aggregate) of large sets like this then it makes sense to store the aggregate and query that instead, fetching <em>much</em> less data.</p>
<p>Unlike rollups, pre-aggregates require only one extra piece of information:</p>
<ul class="simple">
<li><p><strong>Aggregation Function</strong> - What arithmetic was performed on the underlying values to arrive at the new value. E.g. <code class="docutils literal notranslate"><span class="pre">sum</span></code> to add all of the time series or <code class="docutils literal notranslate"><span class="pre">max</span></code> to store the largest.</p></li>
</ul>
<p>In OpenTSDB, pre-aggregates are differentiated from other time series with a special tag. The default tag key is <code class="docutils literal notranslate"><span class="pre">_aggregate</span></code> (configurable via <code class="docutils literal notranslate"><span class="pre">tsd.rollups.agg_tag_key</span></code>). The <strong>aggregation function</strong> used to generate the data is then stored in the tag value in upper-case. Lets look at an example:</p>
<div class="section" id="pre-aggregate-example">
<h3>Pre-Aggregate Example</h3>
<p>Given the example set at the top, we may want to look at the total interface traffic by colo (data center). In that case, we can aggregate by <code class="docutils literal notranslate"><span class="pre">SUM</span></code> and <code class="docutils literal notranslate"><span class="pre">COUNT</span></code> similarly to the rollups. The result would be four <strong>new</strong> time series with meta data like:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Series ID</p></th>
<th class="head"><p>Metric</p></th>
<th class="head"><p>Tag 1</p></th>
<th class="head"><p>Tag 2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ts1’</p></td>
<td><p>system.if.bytes.out</p></td>
<td><p>colo=lga</p></td>
<td><p>_aggregate=SUM</p></td>
</tr>
<tr class="row-odd"><td><p>ts2’</p></td>
<td><p>system.if.bytes.out</p></td>
<td><p>colo=lga</p></td>
<td><p>_aggregate=COUNT</p></td>
</tr>
<tr class="row-even"><td><p>ts3’</p></td>
<td><p>system.if.bytes.out</p></td>
<td><p>colo=sjc</p></td>
<td><p>_aggregate=SUM</p></td>
</tr>
<tr class="row-odd"><td><p>ts4’</p></td>
<td><p>system.if.bytes.out</p></td>
<td><p>colo=sjc</p></td>
<td><p>_aggregate=SUM</p></td>
</tr>
</tbody>
</table>
<p>Notice that these time series have dropped the tags for <code class="docutils literal notranslate"><span class="pre">host</span></code> and <code class="docutils literal notranslate"><span class="pre">interface</span></code>. That’s because, during aggregation, multiple, different values of the <code class="docutils literal notranslate"><span class="pre">host</span></code> and <code class="docutils literal notranslate"><span class="pre">interface</span></code> have been wrapped up into this new series so it no longer makes sense to have them as tags. Also note that we injected the new <code class="docutils literal notranslate"><span class="pre">_aggregate</span></code> tag in the stored data. Queries can now access this data by specifying an <code class="docutils literal notranslate"><span class="pre">_aggregate</span></code> value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With rollups enabled, if you plan to use pre-aggregates, you may want to help differentiate raw data from pre-aggregates by having TSDB automatically inject <code class="docutils literal notranslate"><span class="pre">_aggregate=RAW</span></code>. Just configure the <code class="docutils literal notranslate"><span class="pre">tsd.rollups.tag_raw</span></code> setting to true.</p>
</div>
<p>Now for the resulting data:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Series ID</p></th>
<th class="head"><p>12:00</p></th>
<th class="head"><p>12:15</p></th>
<th class="head"><p>12:30</p></th>
<th class="head"><p>12:45</p></th>
<th class="head"><p>13:00</p></th>
<th class="head"><p>13:15</p></th>
<th class="head"><p>13:30</p></th>
<th class="head"><p>13:45</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ts1’</p></td>
<td><p>8</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>-1</p></td>
<td><p>6</p></td>
<td><p>-4</p></td>
<td><p>6</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>ts2’</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>ts3’</p></td>
<td><p>9</p></td>
<td><p>5</p></td>
<td><p>3</p></td>
<td><p>1</p></td>
<td><p>14</p></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>9</p></td>
</tr>
<tr class="row-odd"><td><p>ts4’</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
<p>Since we’re performing a group by aggregation (grouping by <code class="docutils literal notranslate"><span class="pre">colo</span></code>) we have a value for each timestamp from the original data set. We are <em>not</em> downsampling or performing a rollup in this situation.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>As with rollups, when writing pre-aggregates, it’s best to avoid functions such as <strong>average</strong>, <strong>median</strong> or <strong>deviation</strong>. Just store <strong>sum</strong> and <strong>count</strong></p>
</div>
</div>
</div>
<div class="section" id="rolled-up-pre-aggregates">
<h2>Rolled-up Pre-Aggregates</h2>
<p>While pre-aggregates certainly help with high-cardinality metrics, users may still want to ask for wide time spans but run into slow queries. Thankfully you can roll up a pre-aggregate in the same way as raw data. Just generate the pre-aggregate, then roll it up using the information above.</p>
</div>
<div class="section" id="generating-rollups-and-pre-aggregates">
<span id="generating"></span><h2>Generating Rollups and Pre-Aggregates</h2>
<p>Currently the TSDs do not generate the rollup or pre-aggregated data for you. The primary reason for this is that OpenTSDB is meant to handle huge amounts of time series data so individual TSDs are focused on getting their data into storage as quickly as possible.</p>
<div class="section" id="problems">
<h3>Problems</h3>
<p>Because of the (essentially) stateless nature of the TSDs, they likely won’t have the full set of data available to perform pre-aggregates. E.g., our sample <code class="docutils literal notranslate"><span class="pre">ts1</span></code> data may be written to <code class="docutils literal notranslate"><span class="pre">TSD_A</span></code> while <code class="docutils literal notranslate"><span class="pre">ts2</span></code> is written to <code class="docutils literal notranslate"><span class="pre">TSD_B</span></code>. Neither can perform a proper group-by without reading the data out of storage. We also don’t know at what time we should perform the pre-aggregation. We could wait for 1 minute and pre-aggregate the data but miss anything that came in after that minute. Or we could wait an hour and queries over the pre-aggregates won’t have data for the last hour. And what happens if data comes in much later?</p>
<p>Additionally for rollups, depending on how users write data to TSDs, for <code class="docutils literal notranslate"><span class="pre">ts1</span></code>, we may receive the <code class="docutils literal notranslate"><span class="pre">12:15</span></code> data point on <code class="docutils literal notranslate"><span class="pre">TSD_A</span></code> but the <code class="docutils literal notranslate"><span class="pre">12:30</span></code> value arrives on <code class="docutils literal notranslate"><span class="pre">TSD_B</span></code> so neither has the data required for the full hour. Time windowing constraints also apply to rollups.</p>
</div>
<div class="section" id="solutions">
<h3>Solutions</h3>
<p>Using rollups and pre-aggregates require some analysis and a choice between various trade-offs. Since some OpenTSDB users already have means in place for calculating this kind of data, we simply provide the API to store and query. However here are some tips on how to compute these on your own.</p>
<p><strong>Batch Processing</strong></p>
<p>One method that is commonly used by other time series databases is to read the data out of the database after some delay, calculate the pre-aggs and rollups, then write them. This is the easiest way of solving the problem and works well at small scales. However there are still a number of issues:</p>
<ul class="simple">
<li><p>As data grows, queries for generating the rollups grow as well to the point where the query load impacts write and user query performance. OpenTSDB runs into this same problem when data compactions are enabled under HBase.</p></li>
<li><p>Also as data grows, more data means the batch processing time takes longer and must be sharded across multiple workers which can be a pain to coordinate and troubleshoot.</p></li>
<li><p>Late or historical data may not be rolled up unless some means of tracking is in place to trigger a new batch on old data.</p></li>
</ul>
<p>Some methods of improving batch processing include:</p>
<ul class="simple">
<li><p>Reading from replicated systems, e.g. if you setup HBase replication, you could have users query the master system and aggregations read from the replicated store.</p></li>
<li><p>Read from alternate stores. One example is to mirror all data to another store such as HDFS and run batch jobs against that data.</p></li>
</ul>
<p><strong>Queueing on TSDs</strong></p>
<p>Another option that some databases use is to queue all of the data in memory in the process and write the results after a configured time window has passed. But because TSDs are stateless and generally users put a load balancer in front of their TSDs, a single TSD may not get the full picture of the rollup or pre-agg to be calculated (as we mentioned above). For this method to work, upstream collectors would have to route all of the data required for a calculation to a specific TSD. It’s not a difficult task but the problems faced include:</p>
<ul class="simple">
<li><p>Having enough RAM or disk space to spool the data locally on for each TSD.</p></li>
<li><p>If a TSD process dies, you’ll either loose the data for the aggregation or it must be bootstrapped from storage.</p></li>
<li><p>Whenever the aggregation calculations are taking place, overall write throughput of the raw data can be affected.</p></li>
<li><p>You still have the late/historical data issue.</p></li>
<li><p>Since TSDB is JVM based, keeping all of that data in RAM and then running GC will hurt. A lot. (spooling to disk is better, but then you’ll hit IO issues)</p></li>
</ul>
<p>In general, queueing on a writer is a bad idea. Avoid the pain.</p>
<p><strong>Stream Processing</strong></p>
<p>A better way of dealing with rollups and pre-aggregates is to route the data into a stream processing system where it can be processed in near-real-time and written to the TSDs. It’s similar to the <em>Queuing on TSDs</em> option but using one of the myriad stream processing frameworks (Storm, Flink, Spark, etc.) to handle message routing and in-memory storage. Then you simply write some code to compute the aggregates and spit the data out after a window has passed.</p>
<p>This is the solution used by many next-generation monitoring solutions such as that at Yahoo!. Yahoo is working to open source their stream processing system for others who need monitoring at massive scales and it plugs neatly into TSDB.</p>
<p>While stream processing is better you still have problems to deal with such as:</p>
<ul class="simple">
<li><p>Enough resources for the stream workers to do their job.</p></li>
<li><p>A dead stream worker requires bootstrapping from storage.</p></li>
<li><p>Late/historical data must be handled.</p></li>
</ul>
<p><strong>Share</strong></p>
<p>If you have working code for calculating aggregations, please share with the OpenTSDB group. If your solution is open-source we may be able to incorporate it in the OpenTSDB ecosystem.</p>
</div>
</div>
<div class="section" id="configuration">
<h2>Configuration</h2>
<p id="rollup-configuration">For Opentsdb 2.4, the rollup configuration is referenced by the opentsdb.conf key <code class="docutils literal notranslate"><span class="pre">tsd.rollups.config</span></code>. The value of this key must either but a quote-escaped JSON string without newlines or, preferably, the path to a JSON file containing the configuration. The file name must end with <code class="docutils literal notranslate"><span class="pre">.json</span></code> as in <code class="docutils literal notranslate"><span class="pre">rollup_config.json</span></code>.</p>
<p>The JSON configuration should look something like this:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
      <span class="s2">&quot;aggregationIds&quot;</span><span class="o">:</span> <span class="p">{</span>
              <span class="s2">&quot;sum&quot;</span><span class="o">:</span> <span class="mf">0</span><span class="p">,</span>
              <span class="s2">&quot;count&quot;</span><span class="o">:</span> <span class="mf">1</span><span class="p">,</span>
              <span class="s2">&quot;min&quot;</span><span class="o">:</span> <span class="mf">2</span><span class="p">,</span>
              <span class="s2">&quot;max&quot;</span><span class="o">:</span> <span class="mf">3</span>
      <span class="p">},</span>
      <span class="s2">&quot;intervals&quot;</span><span class="o">:</span> <span class="p">[{</span>
              <span class="s2">&quot;table&quot;</span><span class="o">:</span> <span class="s2">&quot;tsdb&quot;</span><span class="p">,</span>
              <span class="s2">&quot;preAggregationTable&quot;</span><span class="o">:</span> <span class="s2">&quot;tsdb-preagg&quot;</span><span class="p">,</span>
              <span class="s2">&quot;interval&quot;</span><span class="o">:</span> <span class="s2">&quot;1m&quot;</span><span class="p">,</span>
              <span class="s2">&quot;rowSpan&quot;</span><span class="o">:</span> <span class="s2">&quot;1h&quot;</span><span class="p">,</span>
              <span class="s2">&quot;defaultInterval&quot;</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">},</span> <span class="p">{</span>
              <span class="s2">&quot;table&quot;</span><span class="o">:</span> <span class="s2">&quot;tsdb-rollup-1h&quot;</span><span class="p">,</span>
              <span class="s2">&quot;preAggregationTable&quot;</span><span class="o">:</span> <span class="s2">&quot;tsdb-rollup-preagg-1h&quot;</span><span class="p">,</span>
              <span class="s2">&quot;interval&quot;</span><span class="o">:</span> <span class="s2">&quot;1h&quot;</span><span class="p">,</span>
              <span class="s2">&quot;rowSpan&quot;</span><span class="o">:</span> <span class="s2">&quot;1d&quot;</span><span class="p">,</span>
              <span class="s2">&quot;delaySla&quot;</span><span class="o">:</span> <span class="s2">&quot;2h&quot;</span>
      <span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The two top level fields include:</p>
<ul class="simple">
<li><p><strong>aggregationIds</strong> - A map of OpenTSDB aggregation function names to numeric identifiers used for compressed storage.</p></li>
<li><p><strong>intervals</strong> - A list of one or more interval definitions containing table names and interval definitions.</p></li>
</ul>
<div class="section" id="aggregationids">
<h3>aggregationIds</h3>
<p>The aggregation ids map is used for reducing storage by prepending each type of rolled up data with the numeric ID instead of spelling out the full aggregation function. E.g. if we prefixed every column with <code class="docutils literal notranslate"><span class="pre">COUNT:</span></code> that’s 6 bytes for every value (or compacted column) that we can save using an ID.</p>
<p>IDs must be integers from 0 to 127. This means we can store up to 128 different rollups per interval. Only one ID of each numeric value may be provided in the map and only one aggregation function of each type can be given. If a function name does not map to an aggregation function supported by OpenTSDB, an exception will be thrown on start up. Likewise, at least one aggregation must be given for a TSD to start.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The aggregation IDs cannot be changed once you start writing data. If you change mappings, the incorrect data may be returned or queries and writes may fail. You can always add functions in the future but never, ever change the mappings.</p>
</div>
</div>
<div class="section" id="intervals">
<h3>intervals</h3>
<p>Each interval object defines table routing for where rollup and pre-aggregate data should be written to and queried from. There are two types of intervals:</p>
<ul class="simple">
<li><p><strong>Default</strong> - This is the default, <em>raw</em> data OpenTSDB table defined by <code class="docutils literal notranslate"><span class="pre">&quot;defaultInterval&quot;:true</span></code>. For existing installations, this would be the <code class="docutils literal notranslate"><span class="pre">tsdb</span></code> table or whatever is defined in <code class="docutils literal notranslate"><span class="pre">tsd.storage.hbase.data_table</span></code>. Intervals and spans are ignored, defaulting to the OpenTSDB 1 hour row width and storing data with the resolution and timestamp given. Each TSD and configuration can have <em>only one</em> default configured at a time.</p></li>
<li><p><strong>Rollup Interval</strong> - Any interval with <code class="docutils literal notranslate"><span class="pre">&quot;defaultInterval&quot;:false</span></code> or the default interval not set. These are rollup tables where values are snapped to interval boundaries.</p></li>
</ul>
<p>The following fields should be defined:</p>
<p>In storage, rollups are written similar to the raw data in that each row has a base timestamp and each data point is an offset from that base time. Each offset is an increment off of the base time, not an actual offset. For example, if a row stores 1 day of 1 hour data, there would be up to 24 offsets. Offset <code class="docutils literal notranslate"><span class="pre">0</span></code> would map to midnight for the row and offset 5 would map to 6 AM. Because rollup offsets are encoded on 14 bits, if too many intervals would be stored in a row to fit within 14 bits, an error will be thrown when the TSD is started.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>After writing data to a TSD, do <strong>NOT</strong> change the interval widths or row spans for rollup intervals. This will result in garbage data and possibly failed queries.</p>
</div>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="uids.html" title="UIDs and TSUIDs"
             >next</a> |</li>
        <li class="right" >
          <a href="query/stats.html" title="Query Details and Stats"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">OpenTSDB 2.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >User Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Rollup And Pre-Aggregates</a></li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2021, OpenTSDB.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>. Theme by <a href="http://github.com/vkvn">vkvn</a>
    </div>
  </body>
</html>