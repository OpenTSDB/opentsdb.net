<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Trees &mdash; OpenTDSB 2.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/solar.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="OpenTDSB 2.0 documentation" href="../index.html" />
    <link rel="up" title="User Guide" href="index.html" />
    <link rel="next" title="GUI" href="guis/index.html" />
    <link rel="prev" title="Metadata" href="metadata.html" /><link href='http://fonts.googleapis.com/css?family=Source+Code+Pro|Open+Sans:300italic,400italic,700italic,400,300,700' rel='stylesheet' type='text/css'>
<link href="../_static/solarized-dark.css" rel="stylesheet">
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-18339382-1']);
  _gaq.push(['_setDomainName', 'none']);
  _gaq.push(['_setAllowLinker', true]);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="guis/index.html" title="GUI"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="metadata.html" title="Metadata"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">OpenTDSB 2.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">User Guide</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Trees</a><ul>
<li><a class="reference internal" href="#tree-termanology">Tree Termanology</a></li>
<li><a class="reference internal" href="#branch">Branch</a><ul>
<li><a class="reference internal" href="#branch-ids-and-paths">Branch IDs and Paths</a></li>
</ul>
</li>
<li><a class="reference internal" href="#leaves">Leaves</a></li>
<li><a class="reference internal" href="#rules">Rules</a><ul>
<li><a class="reference internal" href="#rule-types">Rule Types</a></li>
<li><a class="reference internal" href="#rule-config">Rule Config</a></li>
<li><a class="reference internal" href="#display-formatter">Display Formatter</a></li>
<li><a class="reference internal" href="#regex-rules">Regex Rules</a></li>
<li><a class="reference internal" href="#separator-rules">Separator Rules</a></li>
<li><a class="reference internal" href="#order-of-precedence">Order of Precedence</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tree-building">Tree Building</a><ul>
<li><a class="reference internal" href="#rule-processing-order">Rule Processing Order</a></li>
<li><a class="reference internal" href="#strict-matching">Strict Matching</a></li>
</ul>
</li>
<li><a class="reference internal" href="#collisions">Collisions</a></li>
<li><a class="reference internal" href="#not-matched">Not Matched</a></li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#result">Result</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="metadata.html"
                        title="previous chapter">Metadata</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="guis/index.html"
                        title="next chapter">GUI</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="trees">
<h1>Trees</h1>
<p>Along with metadata, OpenTSDB 2.0 introduces the concept of <strong>trees</strong>, a hierarchical method of organizing timeseries into an easily navigable structure that can be browsed similar to a file system on a computer. Users can define a number of trees with various rule sets that organize TSMeta objects into a tree structure. Then users can browse the resulting tree via an HTTP API endpoint. See <a class="reference internal" href="../api_http/tree/index.html"><em>/api/tree</em></a> for details.</p>
<div class="section" id="tree-termanology">
<h2>Tree Termanology</h2>
<ul class="simple">
<li><strong>Branch</strong> - Each branch is one node of a tree. It contains a list of child branches and leaves as well as a list of parent branches.</li>
<li><strong>Leaf</strong> - The end of a branch and represents a unique timeseries. The leaf will contain a TSUID value that can be used to generate a TSD query. A branch can, and likely will, have multiple leaves</li>
<li><strong>Root</strong> - The root branch is the start of the tree and all branches reach out from this root. It has a depth of 0.</li>
<li><strong>Depth</strong> - Each time a branch is added to another branch, the depth increases</li>
<li><strong>Strict Matching</strong> - When enabled, a timeseries must match a rule in every level of the rule set. If one or more levels fail to match, the timeseries will not be included in the tree.</li>
<li><strong>Path</strong> - The name and level of each branch above the current branch in the hierarchy.</li>
</ul>
</div>
<div class="section" id="branch">
<h2>Branch</h2>
<p>Each node of a tree is recorded as a <em>branch</em> object. Each branch contains information such as:</p>
<ul class="simple">
<li><strong>Branch ID</strong> - The ID of the branch. This is a hexadecimal value described below.</li>
<li><strong>Display Name</strong> - A name for the branch, parsed from a TSMeta object by the tree rule set.</li>
<li><strong>Depth</strong> - How deep within the hierarchy the branch resides.</li>
<li><strong>Path</strong> - The depth and name of each parent branch (includes the local branch).</li>
<li><strong>Branches</strong> - Child branches one depth level below this branch.</li>
<li><strong>Leaves</strong> - Leaves that belong to this branch.</li>
</ul>
<p>Navigating a tree starts at the <strong>root</strong> branch which always has an ID that matches the ID of the tree the branch belongs to. The root should have one or more child branches that can be used to navigate down one level of the tree. Each child can be used to navigate to their children and so on. The root does not have any parent branches and is always at a depth of 0. If a tree has just been defined or enabled, it may not have a root branch yet, and by extension, there won&#8217;t be any child branches.</p>
<p>Each branch will often have a list of child branches. However if a branch is at the end of a path, it may not have any child branches, but it should have a list of leaves.</p>
<div class="section" id="branch-ids-and-paths">
<h3>Branch IDs and Paths</h3>
<p>Branch IDs are hexadecimal encoded byte arrays similar to TSUIDs but with a different format. Branch IDs always start with the ID of the tree encoded on 2 bytes. Root branches have a branch ID equal to the tree ID. Thus the root for tree <tt class="docutils literal"><span class="pre">1</span></tt> would have a branch ID of <tt class="docutils literal"><span class="pre">0001</span></tt>.</p>
<p>Each child branch has a <tt class="docutils literal"><span class="pre">DisplayName</span></tt> value and the hash of this value is used to generate a 32 bit integer ID for the branch. The hash function used is the Java <tt class="docutils literal"><span class="pre">java.lang.String</span></tt> hash function. The 4 bytes of the integer value are then encoded to 8 hexadecimal characters. For example, if we have a display name of <tt class="docutils literal"><span class="pre">sys</span></tt> for a branch, the hash returned will be 102093. The TSD will convert that value to hexadecimal <tt class="docutils literal"><span class="pre">0001BECD</span></tt>.</p>
<p>A branch ID is composed of the tree ID concatenated with the ID of each parent above the current branch, concatenated with the ID of the current branch. Thus, if our child branch <tt class="docutils literal"><span class="pre">sys</span></tt> is a child of the root, we would have a branch ID of <tt class="docutils literal"><span class="pre">00010001BECD</span></tt>.</p>
<p>Lets say there is a branch with a display name of <tt class="docutils literal"><span class="pre">cpu</span></tt> off of the <tt class="docutils literal"><span class="pre">sys</span></tt> child branch. <tt class="docutils literal"><span class="pre">cpu</span></tt> returns a hash of 98728 which converts to <tt class="docutils literal"><span class="pre">000181A8</span></tt> in hex. The ID of this child would be <tt class="docutils literal"><span class="pre">00010001BECD000181A8</span></tt>.</p>
<p>IDs are created this way primarily due to the method of branch and leaf storage but also as a way to navigate back up a tree from a branch anywhere in the tree structure. This can be particularly useful if you know the end branch of a path and want to move back up one level or more. Unfortunately a deep tree can create very long branch IDs, but a well designed tree really shouldn&#8217;t be more than 5 to 10 levels deep. Most URI requests should support branches up to 100 levels deep before the URI character constraints are reached.</p>
</div>
</div>
<div class="section" id="leaves">
<h2>Leaves</h2>
<p>A unique timeseries is represented as a <em>leaf</em> on the tree. A leaf can appear on any branch in the structure, including the root. But they will usually appear at the end of a series of branches in a branch that has one or more leaves but no child branches. Each leaf contains the TSUID for the timeseries to be used in a query as well as the metric and tag name/values. It also contains a <em>display name</em> that is parsed from the rule set but may not be identical to any of the metric, tag names or tag values.</p>
<p>Ideally a timeseries will only appear once on a tree. But if the TSMeta object for a timeseries, OR the UIDMeta for a metric or tag is modified, it may be processed a second time and a second leaf added. This can happen particularly in situations where a tree has a <em>custom</em> rule on the metric, tag name or tag value where the TSMeta has been processed then a user adds a custom field that matches the rule set. In these situations it is recommended to enable <em>strict matching</em> on the tree so that the timeseries will not show up until the custom data has been added.</p>
</div>
<div class="section" id="rules">
<h2>Rules</h2>
<p>Each tree is dynamically built from a set of rules defined by the user. A rule set must contain at least one rule and usually will have more than one. Each set has multiple <em>levels</em> that determine the order of rule processing. Rules located at level 0 are processed first, then rules at level 1, and so on until all of the rules have been applied to a given timeseries. Each level in the rule set may have multiple rules to handle situations where metrics and tags may not have been planned out ahead of time or some arbitrary data may have snuck in. If multiple rules are stored in a level, the first one with a successful match will be applied and the others ignored. These rules are also ordered by the <em>order</em> field so that a rule with order 0 is processed first, then a rule with order 1 and so on. In logs and when using the test endpoint, rules are usually given IDs in the format of &#8220;[&lt;treeId&gt;:&lt;level&gt;:&lt;order&gt;:&lt;type&gt;]&#8221; such as &#8220;[1:0:1:0]&#8221; indicates the rule for tree 1, at level 0, order 1 of the type <tt class="docutils literal"><span class="pre">METRIC</span></tt>.</p>
<div class="section" id="rule-types">
<h3>Rule Types</h3>
<p>Each rule acts on a single component of the timeseries data. Currently available types include:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="10%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type</th>
<th class="head">ID</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>METRIC</td>
<td>0</td>
<td>Processes the name of the metric associated with the timeseries</td>
</tr>
<tr class="row-odd"><td>METRIC_CUSTOM</td>
<td>1</td>
<td>Searches the metric metadata custom tag list for the given secondary name. If matched, the value associated with the tag name will be processed.</td>
</tr>
<tr class="row-even"><td>TAGK</td>
<td>2</td>
<td>Searches the list of tagks for the given name. If matched, the tagv value associated with the tag name will be processed</td>
</tr>
<tr class="row-odd"><td>TAGK_CUSTOM</td>
<td>3</td>
<td>Searches the list of tagks for the given name. If matched, the tagk metadata custom tag list is searched for the given secondary name. If that matches, the value associated with the custom name will be processed.</td>
</tr>
<tr class="row-even"><td>TAGV_CUSTOM</td>
<td>4</td>
<td>Searches the list of tagvs for the given name. If matched, the tagv metadata custom tag list is searched for the given secondary name. If that matches, the value associated with the custom name will be processed.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="rule-config">
<h3>Rule Config</h3>
<p>A single rule can either process a regex, a separator, or none. If a regex and a separator are defined for a rule, only the regex will be processed and the separator ignored.</p>
<p>All changes to a rule are validated to confirm that proper fields are filled out so that the rule can process data. The following fields must be filled out for each rule type:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type</th>
<th class="head">field</th>
<th class="head">customField</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Metric</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Metric_Custom</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="row-even"><td>TagK</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>TagK_Custom</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="row-even"><td>TagV_Custom</td>
<td>X</td>
<td>X</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="display-formatter">
<h3>Display Formatter</h3>
<p>Occasionally the data extracted from a tag or metric may not be very descriptive. For example, an application may output a timeseries with a tag pair such as &#8220;port=80&#8221; or &#8220;port=443&#8221;. With a standard rule that matched on the tagk value &#8220;port&#8221;, we would have two branches with the names &#8220;80&#8221; and &#8220;443&#8221;. The uninitiated may not know what these numbers mean. Thus users can define a token based formatter that will alter the output of the branch to display useful information. For example, we could declare a formatter of &#8220;{tag_name}: {value}&#8221; and the branches will now display &#8220;port: 80&#8221; and &#8220;port: 443&#8221;.</p>
<p>Tokens are case sensitive and must appear only one time per formatter. They must also appear exactly as deliniated in the table below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="44%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Token</th>
<th class="head">Description</th>
<th class="head">Applicable Rule Type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>{ovalue}</td>
<td>Original value processed by the rule. For example, if the rule uses a regex to extract a portion of the value but you do not want the extracted value, you could use the original here.</td>
<td>All</td>
</tr>
<tr class="row-odd"><td>{value}</td>
<td>The processed value. If a rule has an extracted regex group or the value was split by a separator, this represents the value after that processing has occured.</td>
<td>All</td>
</tr>
<tr class="row-even"><td>{tag_name}</td>
<td>The name of the tagk or custom tag associated with the value.</td>
<td>METRIC_CUSTOM, TAGK_CUSTOM, TAGV_CUSTOM, TAGK</td>
</tr>
<tr class="row-odd"><td>{tsuid}</td>
<td>the TSUID of the timeseries</td>
<td>All</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="regex-rules">
<h3>Regex Rules</h3>
<p>In some situations, you may want to extract only a component of a metric, tag or custom value to use for grouping. For example, if you have computers in mutiple data centers with fully qualified domain names that incorporate the name of the DC, but not all metrics include a DC tag, you could use a regex to extract the DC for grouping.</p>
<p>The <tt class="docutils literal"><span class="pre">regex</span></tt> rule parameter must be set with a valid regular expression that includes one or more extraction operators, i.e. the parentheses. If the regex matches on the value provided, the extracted data will be used to build the branch or leaf. If more than one extractions are provided in the regex, you can use the <tt class="docutils literal"><span class="pre">regex_group_index</span></tt> parameter to choose which extracted value to use. The index is 0 based and defaults to 0, so if you want to choose the output of the second extraction, you would set this index to 1. If the regex does not match on the value or the extraction fails to return a valid string, the rule will be considered a no match.</p>
<p>For example, if we have a host tagk with a tagv of <tt class="docutils literal"><span class="pre">web1.nyc.mysite.com</span></tt>, we could use a regex similar to <tt class="docutils literal"><span class="pre">.*\.(.*)\..*\..*</span></tt> to extract the &#8220;nyc&#8221; portion of the FQDN and group all of the servers in the &#8220;nyc&#8221; data center under the &#8220;nyc&#8221; branch.</p>
</div>
<div class="section" id="separator-rules">
<h3>Separator Rules</h3>
<p>The metrics for a number of systems are generally strings with a separator, such as a period, to deliniate components of the metric. For example, &#8220;sys.cpu.0.user&#8221;. To build a useful tree, you can use a separator rule that will break apart the string based on a character sequence and create a branch or leaf from each individual value. Setting the separator to &#8221;.&#8221; for the previous example would yield three branches &#8220;sys&#8221;, &#8220;cpu&#8221;, &#8220;0&#8221; and one leaf &#8220;user&#8221;.</p>
</div>
<div class="section" id="order-of-precedence">
<h3>Order of Precedence</h3>
<p>Each rule can only process a regex, a separator, or neither. If the rule has both a &#8220;regex&#8221; and &#8220;separator&#8221; value in their respective fields, only the &#8220;regex&#8221; will be executed on the timeseries. The &#8220;separator&#8221; will be ignored. If neither &#8220;regex&#8221; or &#8220;separator&#8221; are defined, then when the rule&#8217;s &#8220;field&#8221; is matched, the entire value for that field will be processed into a branch or leaf.</p>
</div>
</div>
<div class="section" id="tree-building">
<h2>Tree Building</h2>
<p>First, you must create the <tt class="docutils literal"><span class="pre">tsdb-tree</span></tt> table in HBase if you haven&#8217;t already done so. If you enable tree processing and the table does not exist, the TSDs will not start.</p>
<p>A tree can be built in two ways. The <tt class="docutils literal"><span class="pre">tsd.core.tree.enable_processing</span></tt> configuration setting enables real-time tree creation. Whenever a new TSMeta object is created or edited by a user, the TSMeta will be passed through every configured and enabled tree. The resulting branch will be recorded to storage. If a collision occurs or the TSUID failed to match on any rules, a warning will be logged and if the tree options configured, may be recorded to storage.</p>
<p>Alternatively you can periodically synchronize all TSMeta objects via the CLI <tt class="docutils literal"><span class="pre">uid</span></tt> tool. This will scan through the <tt class="docutils literal"><span class="pre">tsdb-uid</span></tt> table and pass each discovered TSMeta object through configured and enabled trees. See <a class="reference internal" href="cli/uid.html"><em>uid</em></a> for details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For real-time tree building you need to enable the <tt class="docutils literal"><span class="pre">tsd.core.meta.enable_tracking</span></tt> setting as well so that TSMeta objects are created when a timeseries is received.</p>
</div>
<p>The general process for creating and building a tree is as follows:</p>
<ol class="arabic simple">
<li>Create a new tree via the HTTP API</li>
<li>Assign one or more rules to the tree via the HTTP API</li>
<li>Test the rules with some TSMeta objects via the HTTP API</li>
<li>After veryfing the branches would appear correctly, set the tree&#8217;s <tt class="docutils literal"><span class="pre">enable</span></tt> flat to <tt class="docutils literal"><span class="pre">true</span></tt></li>
<li>Run the <tt class="docutils literal"><span class="pre">uid</span></tt> tool with the <tt class="docutils literal"><span class="pre">treesync</span></tt> sub command to synchronize existing TSMeta objects in the tree</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When you create a new tree, it will be disabled by default so TSMeta objects will not be processed through the rule set. This is so you have time to configure the rule set and test it to verify that the tree would be built as you expect it to.</p>
</div>
<div class="section" id="rule-processing-order">
<h3>Rule Processing Order</h3>
<p>A tree will usually have more than one rule in order for the resulting tree to be useful. As noted above, rules are organized into levels and orders. A TSMeta is processed through the rule set starting at level 0 and order 0. Processing proceedes through the rules on a level in increasing order. After the first rule on a level that successfully matches on the TSMeta data, processing skips to the next level. This means that rules on a level are effectively <a href="#id1"><span class="problematic" id="id2">``</span></a>or``ed. If level 0 has rules at order 0, 1, 2 and 3, and the TSMeta matches on the rule with an order of 1, the rules with order 2 and 3 will be skipped.</p>
<p>When editing rules, it may happen that some levels or orders are skipped or left empty. In these situations, processing simply skips the empty locations. You should do your best to keep things organized properly but the rule processor is a little forgiving.</p>
</div>
<div class="section" id="strict-matching">
<h3>Strict Matching</h3>
<p>All TSMeta objects are processed through every tree. If you only want a single, monolithic tree to organize all of your OpenTSDB timeseries, this isn&#8217;t a problem. But if you want to create a number of trees for specific subsets of information, you may want to exclude some timeseries entries from creating leaves. The <tt class="docutils literal"><span class="pre">strictMatch</span></tt> flag on a tree helps to filter out timeseries that belong on one tree but not another. With strict matching enabled, a timeseries must match a rule on every level (that has one or more rules) in the rule set in order for it to be included in the tree. If the meta fails to match on any of the levels with rules, it will be recorded as a not matched entry and no leaf will be generated.</p>
<p>By default strict matching is disabled so that as many timeseries as possible can be captured in a tree. If you change this setting on a tree, you may want to delete the existing branches and run a re-sync.</p>
</div>
</div>
<div class="section" id="collisions">
<h2>Collisions</h2>
<p>Due to the flexibility of rule sets and the wide variety of metric, tag name and value naming, it is almost inevitable that two different TSMeta entries would try to create the same leaf on a tree. Each branch can only have one leaf with a given display name. For example, if a branch has a leaf named <tt class="docutils literal"><span class="pre">user</span></tt> with a tsuid of <tt class="docutils literal"><span class="pre">010101</span></tt> but the tree tries to add a new leaf named <tt class="docutils literal"><span class="pre">user</span></tt> with a tsuid of <tt class="docutils literal"><span class="pre">020202</span></tt>, the new leaf will not be added to the tree. Instead, a <em>collision</em> entry will be recorded for the tree to say that tsuid <tt class="docutils literal"><span class="pre">0202020</span></tt> collided with an existing leaf for tsuid <tt class="docutils literal"><span class="pre">010101</span></tt>. The HTTP API can then be used to query the collision list to see if a particular TSUID did not appear in the tree due to a collision.</p>
</div>
<div class="section" id="not-matched">
<h2>Not Matched</h2>
<p>When <em>strict matching</em> is enabled for a tree, a TSMeta must match on a rule on every level of the rule set in order to be added to the tree. If one or more levels fail to match, the TSUID will not be added. Similar to <em>collisions</em>, a not matched entry will be recorded for every TSUID that failed to be written to the tree. The entry will contain the TSUID and a brief message about which rule and level failed to match.</p>
</div>
<div class="section" id="examples">
<h2>Examples</h2>
<p>Assume that our TSD has the following timeseries stored:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="20%" />
<col width="40%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">TS#</th>
<th class="head">Metric</th>
<th class="head">Tags</th>
<th class="head">TSUID</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>cpu.system</td>
<td>dc=dal, host=web1.dal.mysite.com</td>
<td>0102040101</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>cpu.system</td>
<td>dc=dal, host=web2.dal.mysite.com</td>
<td>0102040102</td>
</tr>
<tr class="row-even"><td>3</td>
<td>cpu.system</td>
<td>dc=dal, host=web3.dal.mysite.com</td>
<td>0102040103</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>app.connections</td>
<td>host=web1.dal.mysite.com</td>
<td>010101</td>
</tr>
<tr class="row-even"><td>5</td>
<td>app.errors</td>
<td>host=web1.dal.mysite.com, owner=doe</td>
<td>0101010306</td>
</tr>
<tr class="row-odd"><td>6</td>
<td>cpu.system</td>
<td>dc=lax, host=web1.lax.mysite.com</td>
<td>0102050101</td>
</tr>
<tr class="row-even"><td>7</td>
<td>cpu.system</td>
<td>dc=lax, host=web2.lax.mysite.com</td>
<td>0102050102</td>
</tr>
<tr class="row-odd"><td>8</td>
<td>cpu.user</td>
<td>dc=dal, host=web1.dal.mysite.com</td>
<td>0202040101</td>
</tr>
<tr class="row-even"><td>9</td>
<td>cpu.user</td>
<td>dc=dal, host=web2.dal.mysite.com</td>
<td>0202040102</td>
</tr>
</tbody>
</table>
<p>Note that for this example we won&#8217;t be using any custom value rules so we don&#8217;t need to show the TSMeta objects, but assume these values populate a TSMeta. Also, the TSUIDs are truncated with 1 byte per UID for illustration purposes.</p>
<p>Now let&#8217;s setup a tree with <tt class="docutils literal"><span class="pre">strictMatching</span></tt> disabled and the following rules:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Level</th>
<th class="head">Order</th>
<th class="head">Rule Type</th>
<th class="head">Field (value)</th>
<th class="head">Regex</th>
<th class="head">Separator</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0</td>
<td>TagK</td>
<td>dc</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>TagK</td>
<td>host</td>
<td>.*\.(.*)\.mysite\.com</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>TagK</td>
<td>host</td>
<td>&nbsp;</td>
<td>\\.</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>0</td>
<td>Metric</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>\\.</td>
</tr>
</tbody>
</table>
<p>The goal for this set of rules is to order our timeseres by data center, then host, then by metric. Our company may have thousands of servers around the world so it doesn&#8217;t make sense to display all of them in one branch of the tree, rather we want to group them by data center and let users drill down as needed.</p>
<p>In our example data, we had some old timeseries that didn&#8217;t have a <tt class="docutils literal"><span class="pre">dc</span></tt> tag name. However the <tt class="docutils literal"><span class="pre">host</span></tt> tag does have a fully qualified domain name with the data center name embedded. Thus the first level of our rule set has two rules. The first will look for a <tt class="docutils literal"><span class="pre">dc</span></tt> tag, and if found, it will use that tag&#8217;s value and the second rule is skipped. If the <tt class="docutils literal"><span class="pre">dc</span></tt> tag does not exist, then the second rule will scan the <tt class="docutils literal"><span class="pre">host</span></tt> tag&#8217;s value and attempt to extract the data center name from the FQDN. The second level has one rule and that is used to group on the value of the <tt class="docutils literal"><span class="pre">host</span></tt> tag so that all metrics belonging to that host can be displayed in branches beneath it. The final level has the metric rule that includes a separator to further group the timeseries by the data contained. Since we have multiple CPU and application metrics, all deliniated by a period, it makes sense to add a separator at this point.</p>
<div class="section" id="result">
<h3>Result</h3>
<p>The resulting tree would look like this:</p>
<ul class="simple">
<li>dal<ul>
<li>web1.dal.mysite.com<ul>
<li>app<ul>
<li>connections (tsuid=010101)</li>
<li>errors (tsuid=0101010306)</li>
</ul>
</li>
<li>cpu<ul>
<li>system (tsuid=0102040101)</li>
<li>user (tsuid=0202040101)</li>
</ul>
</li>
<li>web2.dal.mysite.com<ul>
<li>cpu<ul>
<li>system (tsuid=0102040102)</li>
<li>user (tsuid=0202040102)</li>
</ul>
</li>
</ul>
</li>
<li>web3.dal.mysite.com<ul>
<li>cpu<ul>
<li>system (tsuid=0102040103)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>lax<ul>
<li>web1.lax.mysite.com<ul>
<li>cpu<ul>
<li>system (tsuid=0102050101)</li>
</ul>
</li>
</ul>
</li>
<li>web2.lax.mysite.com<ul>
<li>cpu<ul>
<li>system (tsuid=0102050102)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="guis/index.html" title="GUI"
             >next</a> |</li>
        <li class="right" >
          <a href="metadata.html" title="Metadata"
             >previous</a> |</li>
        <li><a href="../index.html">OpenTDSB 2.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >User Guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, OpenTSDB.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>. Theme by <a href="http://github.com/vkvn">vkvn</a>
    </div>
  </body>
</html>